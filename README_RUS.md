# BrickGame Гонки (Go)
Резюме: в данном проекте тебе предстоит реализовать игру «Гонки» на языке программирования Go.

## Содержание

- [BrickGame Гонки (Go)](#brickgame-гонки)
  - [Содержание](#содержание)
  - [Введение](#введение)
  - [Общая информация](#общая-информация)
- [Chapter I](#chapter-i)
    - [Гонки](#гонки)
    - [HTTP](#http)
    - [REST API](#rest-api)
    - [Доставка пользовательского приложения](#доставка-пользовательского-приложения)
    - [Поддержка интерфейсов из предыдущих частей BrickGame](#поддержка-интерфейсов-из-предыдущих-частей-brickgame)
- [Chapter II](#chapter-ii)
  - [Требования к проекту](#требования-к-проекту)
    - [Часть 1. Основное задание](#часть-1-основное-задание)
    - [Часть 2. Дополнительно. Подсчет очков и рекорд в игре](#часть-2-дополнительно-подсчет-очков-и-рекорд-в-игре)
    - [Часть 3. Дополнительно. Механика уровней](#часть-3-дополнительно-механика-уровней)

## Введение

Реализация игры "Гонки" на языке программирования Go будет состоять из разработки нескольких отдельных компонентов: библиотеки, отвечающей за реализацию логики игры, web-интерфейса и сервера, предоставляющего REST API для доступа к играм через сеть.

Разработанную библиотеку также необходимо подключить к консольному интерфейсу из BrickGame v1.0 и десктопному интерфейсу из BrickGame v2.0. Оба интерфейса должны полностью поддерживать новую игру.

Игры из проектов BrickGame v1.0 и BrickGame v2.0 должны быть доступны через разработанный REST API.

В данном проекте предоставлена спецификации REST API, которое необходимо реализовать, и web-интерфейс, который поддерживает данную спецификацию. Эти материалы можно найти в папках `materials` и `code-samples`.

## Chapter I 
## Общая информация

Напоминаем, что для формализации логики игры тебе необходимо использовать конечные автоматы. Чтобы освежить свои знания, описание и примеры КА ты можешь найти `materials/brick-game-v1.0_RUS.md`.

### Гонки

![Гонки](misc/images/race-game.png)

Игра была разработана на основе аркадной игры 1974 года, выпускаемой фирмой Taito, под названием Speed Race. У аркадной игры был физический руль, с помощью которого игрок управлял автомобилем на трассе. Позже концепт данной игры был адаптирован под консоль BrickGame.

В данной игре пользователь управляет гоночной машиной, которая движется по трассе, разделенной на три полосы. В игре постоянно генерируются машины соперников, которые движутся по трассе. Игроку нужно избегать столкновений с машинами соперников, перестраиваясь из полосы в полосу. Генерируемые машины появляются у верхней границы игрового поля и постепенно смещаются вниз, не меняя полосы. При столкновении с машиной соперника игра завершается.

### HTTP

HTTP (HyperText Transfer Protocol) — протокол для передачи гипертекстовых документов, предназначен для клиент-серверного взаимодействия, при котором клиент и сервер обмениваются сообщениями. Сообщения делятся на два типа: запросы и ответы. Запросы отправляются клиентом, ответы — сервером.

Запрос состоит из используемого метода, заголовков и опционального тела запроса, содержащего передаваемые данные. Каждый метод предназначен для выполнения определенного действия на сервере. Из них основными являются:

- `GET` для получения данных;
- `POST` для отправки данных;
- `DELETE` для удаления данных;
- `PATCH`  для редактирования данных.

При отправке данные помещаются в тело запроса, при этом формат передачи данных может быть разным: обычный текст, XML, JSON и т.д. В основном используют JSON из-за его читаемости и поддержки в языке JavaScript.

Ответ состоит из кода ответа, заголовков и тела запроса. Заголовки и тело запроса используются таким же образом как и в запросах. Код ответа же предназначен для передачи клиенту информации о результате запроса. Они состоят из трех цифр и делятся на пять групп. Коды каждой группы начинаются со своей цифры:

- информационная (100-199),
- успешные (200-299),
- перенаправления (300-399),
- клиентские ошибки (400-499),
- серверные ошибки (500-599).

### REST API

API (Application Programming Interface) предназначен для формализации способов взаимодействия между программами.

REST API — это архитектурный подход к построению Web API. Для построения REST API необходимо выделить все ресурсы, к которым будет предоставлен доступ. После этого для каждого ресурса нужно выделить все доступные операции и логически сгруппировать их по маршрутам, используя различные методы, параметры и фильтры.

Возьмем, к примеру, сайт библиотеки. Мы хотим предоставить список доступных книг с возможностью поиска по автору. Тогда у нас будет два ресурса: книга и автор. Для автора у нас будет только один маршрут — получение списка всех авторов. Для книг у нас будет два маршрута: получение списка всех книг и получение информации о конкретной книге.

- `server_url/api/authors` — маршрут для получения списка авторов;
- `server_url/api/books?author_id=<id>` — маршрут для получения списка книг, где `author_id` - фильтр для получения книг только заданного автора. Фильтр можно опустить, тогда будет выдан список всех книг;
- `server_url/api/books/<id>` — получение информации о конкретной книге по идентификатору. `id` — параметр маршрута.

Как можно заметить выше, ресурсы в маршрутах всегда во множественном числе.

Применяя методы HTTP, можно использовать один и тот же маршрут для разных задач. Используя маршрут `server_url/api/books/<id>` и метод `GET`, можно запросить информацию по конкретной книге. Если же сервер дает возможность удалять ресурсы, то этот же маршрут может использоваться и для удаления, только вместо метода `GET` будет метод `DELETE`.

### Доставка пользовательского приложения

Для запуска пользовательского приложения в браузере его необходимо сначала загрузить. Для этого необходимо настроить раздачу статический файлов (html, css, js) на сервере. Есть два способа: мы можем раздавать статику с помощью нашего серверного приложения или настроить отдельный сервер для раздачи статики. Первый подход увеличивает нагрузку на серверное приложение, что может стать проблемой в реальных проектах, но несколько упрощает задачу, т.к. у большинства языков это настраивается добавлением нескольких строк кода. Второй подход позволяет разгрузить серверное приложение и ускорить раздачу статических файлов, т.к. для этого используются специально разработанные для этого приложения (например, Nginx), но требует дополнительной настройки.

### Поддержка интерфейсов из предыдущих частей BrickGame

Подключение игровой библиотеки нужно осуществить посредством REST API. Чтобы подключить игру таким образом, для консольного и десктопного интерфейса нужно разработать небольшую библиотеку-клиента, инкапсулирующую обращение к API и предоставляющую универсальный интерфейс.

## Chapter II 
## Требования к проекту

### Часть 1. Основное задание

Тебе необходимо реализовать BrickGames v3.0:

- Сервер должен быть разработан на языке Go.
- При формализации игровой логики необходимо использовать конечные автоматы.
- Реализуй REST API для клиент-серверного взаимодействия. Он должен соответствовать спецификации, которая находится в файле `materials/rest-api-specification.yaml`.
- Логика игры должна быть реализована в библиотеке, которую необходимо поместить в папку `src/brick_game/race`.
- Код сервера должен находиться в папке `src/brick_game/server`.
- Код для web-интерфейса необходимо поместить в папку `src/brick_game/web_gui` (можешь использовать готовый интерфейс, который находится в папке `code-samples/web-gui`).
- При написании кода придерживайся Effective Go.
- Библиотека, реализующая логику игры, должна быть покрыта unit-тестам с использованием фреймворка `testify`. Особое внимание удели проверке состояний и переходами КА. Покрытие библиотеки с логикой игры тестами должно составлять не меньше 80 процентов.
- Настрой раздачу статических файлов.
- В игре гонки должны присутствовать следующие механики:
  - Машина игрока может менять полосу при нажатии стрелок влево/вправо;
  - При столкновении с другой машиной игра заканчивается;
  - Машины противника появляются у верхнего края игрового поля и постепенно смещаются вниз;
  - При зажатии стрелки вперед машины противников смещаются с увеличенной скоростью, которая отображается в интерфейсе.
- Перенеси папку библиотеки с логикой игры из проекта BrickGame v1.0 в данный проект.
- Перенеси папку библиотеки с логикой игры из проекта BrickGame v2.0 в данный проект.
- Перенеси папку с консольным интерфейсом игры из проекта BrickGame v1.0.
- Перенеси папку с десктопным интерфейсом игры из проекта BrickGame v2.0.
- Сервер должен поддерживать игры из предыдущих проектов BrickGame.
- Консольный интерфейс должен поддерживать игру гонки.
- Десктопный интерфейс должен поддерживать игру гонки.
- Для взаимодействия с REST API разработай библиотеку-клиента, инкапсулирующую взаимодействие с сервером. Данная библиотека должна использоваться для поддержания игры в консольном и десктопном клиентах. Она должна предоставлять универсальный интерфейс, описанный в `materials/library-specification_RUS.md`.
- Размер игрового поля должен быть 10 «пикселей» в ширину и 20 «пикселей» в высоту.
- У игровой библиотеки должен быть универсальный интерфейс, описанный в файле `materials/library-specification_RUS.md`.
- Подготовь для сдачи проекта диаграмму, отображающую все состояния и переходы между ними для реализованного КА.

### Часть 2. Дополнительно. Подсчет очков и рекорд в игре

Добавь в игру следующие механики:

- подсчет очков,
- хранение максимального количества очков.

Данная информация должна передаваться и выводиться пользовательским интерфейсом в боковой панели. Максимальное количество очков должно храниться в файле или встраиваемой СУБД и сохраняться между запусками программы.

Максимальное количество очков должно изменяться во время игры, если пользователь во время игры превышает текущий показатель максимального количества набранных очков.

Начисление очков будет происходить следующим образом: каждый обгон приносит одно очко.

### Часть 3. Дополнительно. Механика уровней

Добавь в игру механику уровней. Каждый раз, когда игрок набирает 5 очков, уровень увеличивается на 1. Повышение уровня увеличивает скорость движения машин. Максимальное количество уровней — 10.

[Нажми сюда](https://forms.yandex.ru/cloud/65d4c115eb6146203c13ff8b/), **чтобы поделиться с нами обратной связью на этот проект**. Это анонимно и поможет нашей команде сделать твоё обучение лучше.
